<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet version="1.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
    xmlns:msxsl="urn:schemas-microsoft-com:xslt"
    xmlns:fo="http://www.w3.org/1999/XSL/Format"
    xmlns:user="urn:my-scripts">

    <xsl:output method="text" omit-xml-declaration="yes" indent="no"/>
    <xsl:strip-space elements="*" />

    <!--

    SWIG's XML describes the interface in a highly structured way, 
    *except* for types, which are encoded as mysterious strings like this
    "q(const).model::OutputPort&lt;(double)>" 

    Parsing these strings is too much for XSLT's capabilities, so we've 
    had to supplement vanilla XSLT with C# code. The embedded C# code
    requires an XSLT engine that understands this embedding, hence the
    LaunchXslt program, which uses .NET's powerful XSLT engine.

    -->

    <msxsl:script language="C#" implements-prefix="user">
     <![CDATA[

    public static string TryRegexpPrefix(string regexp, string encodedType)
    {
        var nsRx = new System.Text.RegularExpressions.Regex(regexp);
        var m = nsRx.Match(encodedType);
        if (m.Success) return m.Groups[1].Value;
        return null;
    }

    // This method is horribly heuristic based on the mix of types we use in ELL.
    // We could invest in really learning SWIG's weird string syntax, but is it worth it?
    //
    public static string TranslateType(string encodedType)
    {
        var ltIndex = encodedType.IndexOf("<(");
        if (ltIndex >= 0) // it's a template instance
        {
            var typeName = TranslateType(encodedType.Substring(0, ltIndex));
            var gtIndex = encodedType.LastIndexOf(")>");
            var parmStrings = encodedType.Substring(ltIndex + 2, gtIndex - ltIndex - 2).Split(',');
            var parms = new string[parmStrings.Length];
            for (int i=0; i<parms.Length; i++)
              parms[i] = TranslateType(parmStrings[i]);
            return typeName + "<" + String.Join(",", parms) + ">";
        }

        var rest = 
            TryRegexpPrefix(@"r\.q\(const\)\.(.*)", encodedType) ??
            TryRegexpPrefix(@"q\(const\)\.(.*)", encodedType) ??
            TryRegexpPrefix(@"r\.(.*)", encodedType) ??
            TryRegexpPrefix(@"z\.(.*)", encodedType) ??
            TryRegexpPrefix("^[A-Za-z0-9]+::(.*)", encodedType);
        if (rest != null) return TranslateType(rest);

        switch (encodedType)
        {
            case "void": return "void";
            case "bool": return "boolean";
            case "char": return "number";
            case "short": return "number";
            case "int": return "number";
            case "float": return "number";
            case "double": return "number";
            case "uint64_t": return "number";
            case "size_t": return "number";
            case "string": return "string";
            case "nullptr_t": return "any";
        }

        var ident = TryRegexpPrefix("^([A-Za-z0-9_]+)$", encodedType);
        if (ident != null) return ident;

        return "any /*!!!" + encodedType + "*/"; // This should not appear in the final file!
    }

      ]]>
    </msxsl:script>



    <xsl:template match="/">

<!-- 

We start the output file with a standard header that includes any types
that ELL uses but doesn't define itself. Hopefully this list will be
short, perhaps even empty once ELL has a nice white-listed API.

-->

        <xsl:text>
/*
  THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
*/

//----------------------------------------------------------------------------------
// Definitions from utility libraries that are not in the SWIG XML file.
//----------------------------------------------------------------------------------

export class CommandLineParser {}
export class CommandLineParseResult {}
export class ostream {}
export class XMLDeserializer {}
export class XMLSerializer {}

export class StlIterator&lt;T,U&gt; {
    IsValid(): boolean;
    HasSize(): boolean;
    NumIteratesLeft(): number;
    Next(): void;
    Get(): T;
}

export class StdVector&lt;T&gt; {
    constructor();
    constructor(count: number);
    size(): number;
    capacity(): number;
    reserve(count: number): void;
    empty(): boolean;
    clear(): void;
    add(val: T): void;
    get(index: number): T;
    set(index: number, val: T): void;
}

export class RowDataset&lt;T&gt; {
    // fill me in
}

export class Iterator extends StlIterator&lt;any,any&gt; { 
    // For now, I'm translating Iterators in a weakly typed way.
    // If we feel it's important we could put in the work to 
    // translate C++ templates properly to preserve strong typing.
}

export class StringVector extends StdVector&lt;string&gt; {}

export class FeatureMap {
    // fill me in
}

export class SupervisedExample&lt;T&gt; {
    // fill me in
}

export class SparseDataVector&lt;T,U&gt; {
    // fill me in
}

export class CompressedIntegerList {
    // fill me in
}

export class vector&lt;T&gt; {
    // fill me in
}

export class TypeFactory&lt;T&gt; {
    // fill me in
}

export class AnyIterator&lt;T&gt; {
    // fill me in
}

export type unique_ptr&lt;T&gt; = T; // Is this right?
export type shared_ptr&lt;T&gt; = T; // Is this right?

//----------------------------------------------------------------------------------
// Translated definitions below. 
// (The id comments allow traceability back to the SWIG XML file.)
//----------------------------------------------------------------------------------
&#10;&#10;&#10;</xsl:text>
        <xsl:apply-templates/>
    </xsl:template>

    <!--

     The translation rules start here.  

     -->

    <xsl:template match="namespace">
        <!-- Keep track of when we're inside namespaces, to recognize top-level functions. -->
        <xsl:apply-templates mode="inside-namespace" />
    </xsl:template>


    <!-- classes -->
    <xsl:template match="class" mode="inside-namespace">
        <xsl:if test="attributelist/attribute[@name='sym_name'] and
            not(attributelist/attribute[@name='sym_name' and starts-with(@value, '__')])">
            <xsl:text>export class </xsl:text>
            <xsl:value-of select="attributelist/attribute[@name='sym_name']/@value"/>
            <xsl:text> { // class id:</xsl:text>
            <xsl:value-of select='@id'/>
            <xsl:text>&#10;</xsl:text>
            <xsl:apply-templates mode="inside-class"/>
            <xsl:text>}&#10;&#10;&#10;</xsl:text>
        </xsl:if>
    </xsl:template>


    <!-- templates: skip for now. I'm not sure SWIG even supports that. -->
    <xsl:template match="template" mode="inside-namespace">
        <xsl:text>// skipping template </xsl:text>
        <xsl:value-of select="attributelist/attribute[@name='sym_name']/@value"/>
        <xsl:text> id:</xsl:text>
        <xsl:value-of select='@id'/>
        <xsl:text>&#10;&#10;&#10;</xsl:text>
    </xsl:template>


    <!-- constructors -->
    <xsl:template match="constructor/attributelist" mode="inside-class">
        <xsl:text>&#9;constructor(</xsl:text>
        <xsl:for-each select="parmlist/parm">
            <xsl:if test="position() != 1"><xsl:text>, </xsl:text></xsl:if>
            <xsl:choose>
                <xsl:when test="attributelist/attribute[@name='name']">
                    <xsl:value-of select="attributelist/attribute[@name='name']/@value"/>
                </xsl:when>
                <xsl:otherwise><xsl:text>parameter</xsl:text></xsl:otherwise>
            </xsl:choose>
            <xsl:text>: </xsl:text>
            <xsl:value-of select="user:TranslateType(attributelist/attribute[@name='type']/@value)"/>
        </xsl:for-each>
        <xsl:text>); // ctor id:</xsl:text>
        <xsl:value-of select="@id"/>
        <xsl:text>&#10;</xsl:text>
    </xsl:template>


    <!-- methods and fields -->
    <xsl:template match="cdecl/attributelist[attribute[@name='kind' and (@value='variable' or @value='function')]]" mode="inside-class">
        <!-- translate every cdel with 
        (1) an attribute name 'access' and value 'public' 
        (2) a 'name' attribute that does not contain 'operator ' -->
        <xsl:if test="attribute[@name='access' and @value='public'] and 
                      not(attribute[@name='name' and contains(@value, 'operator ')])">
            <xsl:text>&#9;</xsl:text>
            <xsl:value-of select="attribute[@name='name']/@value"/>
            <xsl:if test="not(attribute[@name='kind' and @value='variable'])">
                <xsl:text>(</xsl:text>
                <xsl:for-each select="parmlist/parm">
                    <xsl:if test="position() != 1"><xsl:text>, </xsl:text></xsl:if>
                    <xsl:value-of select="attributelist/attribute[@name='name']/@value"/>
                    <xsl:text>: </xsl:text>
                    <xsl:value-of select="user:TranslateType(attributelist/attribute[@name='type']/@value)"/>
                </xsl:for-each>
                <xsl:text>)</xsl:text>
            </xsl:if>
            <xsl:text>: </xsl:text>
            <xsl:value-of select="user:TranslateType(attribute[@name='type']/@value)"/>
            <xsl:text>; // member id:</xsl:text>
            <xsl:value-of select="@id"/>
            <xsl:text>&#10;</xsl:text>
        </xsl:if>
    </xsl:template>


    <!-- typedefs -->
    <xsl:template match="cdecl/attributelist[attribute[@name='kind' and @value='typedef']]" mode="inside-namespace">
        <xsl:if test="attribute[@name='sym_name']">
            <xsl:text>export class </xsl:text>
            <xsl:value-of select="attribute[@name='sym_name']/@value"/>
            <xsl:text> extends </xsl:text>
            <!-- NOTE: I could find no built-in functions for getting the info needed, so I had to rely on scripting. -->
            <xsl:value-of select="user:TranslateType(attribute[@name='type']/@value)"/>
            <xsl:text> { } // typedef id:</xsl:text>
            <xsl:value-of select="@id"/>
            <xsl:text>&#10;&#10;&#10;</xsl:text>
        </xsl:if>
    </xsl:template>


    <!-- top-level functions -->
    <xsl:template match="cdecl/attributelist[attribute[@name='kind' and @value='function']]" mode="inside-namespace" >
        <xsl:if test="not(attribute[@name='access' and @value='private']) and 
            not(attribute[@name='name' and contains(@value, 'operator ')])">
            <xsl:text>export function </xsl:text>
            <xsl:choose>
                <xsl:when test="contains(attribute[@name='name']/@value, '::')">
                    <xsl:value-of select="substring-after(attribute[@name='name']/@value, '::')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="attribute[@name='name']/@value"/>
                </xsl:otherwise>
            </xsl:choose>            
            <xsl:text>(</xsl:text>
            <xsl:for-each select="parmlist/parm">
                <xsl:if test="position() != 1"><xsl:text>, </xsl:text></xsl:if>
                <xsl:value-of select="attributelist/attribute[@name='name']/@value"/>
                <xsl:text>: </xsl:text>
                <xsl:value-of select="user:TranslateType(attributelist/attribute[@name='type']/@value)"/>
            </xsl:for-each>
            <xsl:text>): </xsl:text>
            <xsl:value-of select="user:TranslateType(attribute[@name='type']/@value)"/>
            <xsl:text>; // function id:</xsl:text>
            <xsl:value-of select="../@id"/>
            <xsl:text>&#10;&#10;</xsl:text>
        </xsl:if>
    </xsl:template>

    <!-- enums -->
    <xsl:template match="enum" mode="inside-class">
        <xsl:if test="not(attributelist/attribute[@name='access' and @value='private'])">
        <xsl:text>enum </xsl:text>
        <xsl:value-of select="attributelist/attribute[@name='sym_name']/@value"/>
        <xsl:text>{</xsl:text>
        <xsl:for-each select="enumitem/attributelist">
            <xsl:value-of select="attribute[@name='sym_name']/@value" />
            <xsl:text>,</xsl:text>
        </xsl:for-each>
        <xsl:text>}&#10;</xsl:text>
        </xsl:if>
    </xsl:template>

</xsl:stylesheet>
